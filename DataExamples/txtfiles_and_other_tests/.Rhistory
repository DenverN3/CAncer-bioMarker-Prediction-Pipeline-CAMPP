my.fit <- cv.glmnet(x = t(my.data), y = my.groups, family="multinomial", type.multinomial = "grouped", nfolds = 10)
my.coef <- coef(my.fit, s=my.fit$lambda.min)
my.ma <- as(my.coef$`1`, "matrix")
rm(my.fit)
rm(my.coef)
}
else {
set.seed(my.seed)
my.fit <- cv.glmnet(x = t(my.data), y = my.groups, family = "binomial", type.measure = "class", nfolds = 10)
my.coef <- coef(my.fit, s=my.fit$lambda.min)
my.ma <- as(my.coef, "matrix")
rm(my.fit)
rm(my.coef)
}
my.ma <- names(my.ma[my.ma[,1] != 0, ])
#my.ma <- my.data[rownames(my.data) %in% my.ma, ]
return(my.ma)
}
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# KEGG FUNCTION
# Takes as arguments:
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
mirnaPwEnrich <- function(my.pathway, my.background, my.query, simple=NULL) {
BGSetcount <- data.frame(as.numeric(unlist(lapply(my.pathway, function(x) length(intersect(x, my.background))))))
colnames(BGSetcount) <- c("inPWBG")
BGSetcount$notPWBG <- length(my.background)-BGSetcount$inPWBG
BGSetcount$isPWSet  <- as.numeric(unlist(lapply(my.pathway, function(x) length(intersect(x, my.query)))))
BGSetcount$notPWSet <- length(my.query)-BGSetcount$isPWSet
rownames(BGSetcount) <- names(my.pathway)
my.fishers <- apply(BGSetcount, 1, function(x) fisher.test(matrix(x,nr=2))[1:3])
if (!is.null(simple)) {
my.fishers <- do.call(rbind, lapply(my.fishers, function(x) data.frame(x[1][[1]], x[3][[1]], x[2][[1]][1], x[2][[1]][2])))
colnames(my.fishers) <- c("Pval", "OR", "Lower", "Upper")
my.fishers$FDR <- p.adjust(my.fishers$Pval, method = "fdr")
}
return(my.fishers)
}
# my.pathways <- c()
# for (idx in 1:length(my.fishers)) {
#   if(my.fishers[[idx]]$p.value <= cutoff) {
#     enriched <- names(my.fishers[idx])
#     my.pathways[idx] <- enriched
#   }
# }
# my.fishers <- my.pathways[-c(which(is.na(my.pathways)))]
geneTarPwEnrich <- function(my.background, my.query, my.coFDR, top.n) {
forKegg <- replicate(length(my.query), 0)
names(forKegg) <- my.query
kk <- as.data.frame(enrichKEGG(my.query, universe = my.background, pvalueCutoff=my.coFDR, pAdjustMethod="BH", qvalueCutoff=0.1))
# If many significant KEGG pathways get the top 5
if(length(kk$ID) > 5) {
pid <- kk$ID[1:top.n]
} else {
pid <- kk$ID
}
# Write out results
pv.out.list <- lapply(pid, function(x) pathview(gene.data=forKegg, pathway.id=x, species="hsa", gene.idtype="KEGG", both.dirs = TRUE))
return(kk)
}
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Correlation ANALYSIS
# Takes as arguments:
# d1 and d2 dataframes of expression values to correlate
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
my_correlation <- function(d1, d2) {
my.names <- rownames(d1)
d1 <- as.matrix(as.data.frame(lapply(d1, as.numeric)))
d2 <- as.matrix(as.data.frame(lapply(d2, as.numeric)))
spear_corr <- sapply(1:nrow(d1), function(i) cor(d1[i,], d2[i,], method = "spearman"))
spear_corr <- data.frame(spear_corr)
colnames(spear_corr) <- "cor_coef"
# pearson correlation p-values
spear_p_val <- sapply(1:nrow(d1), function(i) cor.test(d1[i,], d2[i,], method = "spearman")$p.value)
spear_p_val <- data.frame(spear_p_val)
colnames(spear_p_val) <- "pval"
# correction for multiple testing with fdr
fdr <- data.frame(p.adjust(spear_p_val$pval, method = "fdr"))
colnames(fdr) <- "fdr"
spear_corr_full <- cbind(spear_corr, spear_p_val, fdr)
rownames(spear_corr_full) <- my.names
return(spear_corr_full)
}
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# miRNA-miRNA co-expression network with spearman analysis.
# Takes as arguments:
# data = a dataframe with expression/abundance counts
# direction = vector specifying if the given miRNA is up -or down regulated in the given comparison ("up" or "down")
# coCorr, coFDR = cut-off for significant fdr and correlation
# name = name of output file (as string)
# IF genes=NULL then only miRNAs will be used, or the user may provide a list of miRNA-gene targets.
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
my_networks <- function(data, direction, coCorr, coFDR, name, genes=NULL) {
# Making pairwise combinations
combinations <- combs(as.character(rownames(data)), 2)
# Node 1
df1_names <- data.frame(combinations[,1])
colnames(df1_names) <- "first"
# Node 2
df2_names <- data.frame(combinations[,2])
colnames(df2_names) <- "second"
# Creating temporary DF
temp_data <- data
names <- rownames(temp_data)
first <- rownames(temp_data)
rownames(temp_data) <- NULL
temp_data <- cbind(temp_data, names, first)
# Merging node 1 miRNAs with their expression values
df1 <- merge(df1_names, temp_data, by="first", sort = FALSE)
df1 <- cbind(df2_names, df1)
df1 <- with(df1, df1[order(second) , ])
df2_names <- data.frame(df1$second)
colnames(df2_names) <- "names"
df1_names <- data.frame(df1$first)
colnames(df1_names) <- "first"
df1 <- as.matrix(df1[,!(names(df1) %in% c("first", "second", "names"))])
# Merging node 2 miRNAs with their expression values
df2 <- merge(df2_names, temp_data, by="names", sort = FALSE)
df2 <- as.matrix(df2[,!(names(df2) %in% c("first", "names"))])
#
spear_corr <- sapply(1:nrow(df1), function(i) cor(df1[i,], df2[i,], method = "spearman"))
spear_corr <- data.frame(spear_corr)
colnames(spear_corr) <- "cor_coef"
# spearman correlation p-values
spear_p_val <- sapply(1:nrow(df1), function(i) cor.test(df1[i,], df2[i,], method = "spearman")$p.value)
spear_p_val <- data.frame(spear_p_val)
colnames(spear_p_val) <- "pval"
# correction for multiple testing with fdr
fdr <- data.frame(p.adjust(spear_p_val$pval, method = "fdr"))
colnames(fdr) <- "fdr"
spear_corr_full <- cbind(df1_names, df2_names, spear_corr, fdr)
spear_corr_full$cor_dir <- ifelse(spear_corr_full$cor_coef >= 0, "+", "-")
spear_corr_full$cor_coef <- abs(spear_corr_full$cor_coef)
spear_sig <- spear_corr_full[spear_corr_full$cor_coef >= coCorr & spear_corr_full$fdr < coFDR, ]
max_min <- range(spear_sig$fdr[spear_sig$fdr != 0])
spear_sig$fdr <- ifelse(spear_sig$fdr == 0, max_min[1], spear_sig$fdr)
spear_sig$inverse_fdr <- -1*log(spear_sig$fdr)
spear_sig <- merge(spear_sig, direction, by ="first")
spear_sig$node1 <- unlist(lapply(spear_sig$first, function(x) gsub("-[0-9]{6}", "", x, perl=TRUE)))
spear_sig$node2 <- unlist(lapply(spear_sig$names, function(x) gsub("-[0-9]{6}", "", x, perl=TRUE)))
spear_sig <- spear_sig[,!(names(spear_sig) %in% c("first", "names"))]
spear_sig$dir <- ifelse(spear_sig$cor_dir == '+' & spear_sig$direction == "up", "u", "o")
spear_sig$dir <- ifelse(spear_sig$cor_dir == '+' & spear_sig$direction == "down", "d", spear_sig$dir)
if (!is.null(genes)) {
nodes <- unique(c(spear_sig$node1, spear_sig$node2))
genes <- genes[genes$miRNAs %in% nodes, ]
genes <- data.frame(replicate(4, replicate(nrow(genes), 0)), replicate(nrow(genes), "N"), genes[,1:2], replicate(nrow(genes), "N"))
colnames(genes) <- colnames(spear_sig)
spear_sig <- rbind(spear_sig, genes)
}
write.table(spear_sig, paste0(name,"expression_correlation.txt"), sep="\t", quote = FALSE, row.names = FALSE)
return(spear_sig)
}
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Get module genes from WGCNA and network correlations
# Takes as arguments:
# my.nwk = Out from the my_networks function above
# my.genes = list of genes of interest
# my.list.modules = list of gene modules from the WGCNA analysis
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
get_module_gene <- function(my.nwk, my.genes, my.list.modules) {
mod <- lapply(my.list.modules, function(x)  my.nwk[my.nwk$node1 %in% x$name & my.nwk$node2 %in% x$name|my.nwk$node1 %in% x$name & my.nwk$node2 %in% my.genes|my.nwk$node2 %in% x$name & my.nwk$node1 %in% my.genes, ])
return(mod)
}
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Fisher Test
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#my.fisher <- function(notfoc1, isfoc1, notfoc2, isfoc2) {
#  my.mat <-matrix(c(length(isfoc1),(length(notfoc1)-length(isfoc1)), length(isfoc2),(length(notfoc2)-length(isfoc2))), nrow = 2, dimnames =list(c("isfoc", "notfoc"), c("ALL", "Clusters")))
#  fisher.test(my.mat)
#}
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# FUNCTION FOR GENERATING SURVIVAL PLOT
# Takes as arguments;
# A survival object in the form of a list with a cox regression for each variable (N-glycan).
# A title of plot
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
number_ticks <- function(n) {function(limits) pretty(limits, n)}
my_survival <- function(my.survivaldata, my.title, pcol) {
survival_conf <- data.frame(do.call(rbind, lapply(my.survivaldata, function(x) summary(x)$conf.int[nrow(summary(x)$conf.int),c(1,3,4)])))
colnames(survival_conf) <- c("HR", "lower", "upper")
survival_pvals <- do.call(rbind, lapply(my.survivaldata, function(x) summary(x)$coefficients[nrow(summary(x)$coefficients),pcol]))
survival_fdr <- p.adjust(survival_pvals[,1], method = "fdr", n=nrow(survival_pvals))
survival_conf$miRNA <- as.factor(as.numeric(1:length(my.survivaldata)))
survival_conf$pval <- survival_pvals[,1]
survival_conf$fdr <- survival_fdr
survival_conf$sig <- as.factor(ifelse(survival_conf$fdr <=0.05, 1, 0))
p <- ggplot(survival_conf, aes(x=miRNA , y=HR, label=round(HR,2))) + geom_point(aes(colour = sig), size=8) + scale_color_manual(values=c("black", "cyan3")) + geom_text(color="white", size=3) + geom_errorbar(aes(ymax = upper, ymin = lower)) + geom_hline(yintercept=1) + scale_x_discrete(limits=as.character(survival_conf$miRNA)) + theme_bw() + theme(axis.text.x = element_text(size=10, color = "black", angle = 90, hjust = 1), axis.text.y = element_text(size=12, color = "black"), axis.title = element_text(size=15)) + theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_line( size=.1, color="black" )) + scale_y_continuous(breaks=number_ticks(10)) + ggtitle(my.title) + xlab("miRNAs") + ylab("Hazard Ratio") + scale_y_continuous(trans = log2_trans(), breaks = trans_breaks("log2", function(x) 2^x),labels = trans_format("log2", math_format(2^.x)))
return(list(survival_conf, p))
}
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# FUNCTION FOR GENERATING SURVIVAL GGPLOT CURVES
# Takes as arguments;
# a dataframe with abundances
# a dataframe with survivalinfo
# indices of features (glycans) to use
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
my_survival_curve <- function(my.data, my.survivaldata, my.index) {
GPs <- lapply(my.index, function(x) data.frame(as.numeric(my.data[x,]), my.survivaldata$time_to_Outcome_years, my.survivaldata$Outcome_status, my.survivaldata$Age_at_surgery))
GPs <- lapply(GPs, setNames, c("GP", "years", "status", "age"))
GPs <- lapply(GPs, function(x) coxph(Surv(years, status) ~ age + GP, data = x))
return(GPs)
}
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Plot UpSetR
# Takes as arguments;
# list.of.sets = list with sets to plot
# my.intersection = the names of the sets to intersect
# my.name = name of output plot
# my.cols = colors vector with as, one color per set
# if my.plot= TRUE a pdf is writen out, og write.ids = TRUE, write out intersection of all sets
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
plot_upsetR <- function(list.of.sets, my.intersection, my.name, my.cols, my.plot, write.ids) {
full.set <- data.frame(unique(sort(c(unlist(list.of.sets)))))
colnames(full.set) <- "miRNA"
for (name in  names(list.of.sets)) {
full.set <- data.frame(full.set, ifelse(full.set$miRNA %in% as.character(list.of.sets[[name]]), 1, 0))
}
colnames(full.set) <- c("miRNA", names(list.of.sets))
metadata <- data.frame("sets" = colnames(full.set)[-1], "sets2" = colnames(full.set)[-1])
if (my.plot==TRUE) {
pdf(paste0(my.name, ".pdf"), height = 7, width = 10)
par(cex=0.6, mar = c(6,2,2,6))
upset(full.set, sets=colnames(full.set)[2:ncol(full.set)], sets.bar.color = my.cols, set.metadata = list(data = metadata, plots = list(list(type="matrix_rows", column = "sets", colors = c("TIF_NIF" = my.cols[1], "Clus1_Clus2"= my.cols[2], "PGRm_PGRp"=my.cols[3], "TILSH_TILSL" = my.cols[4], "GRH_GRL" = my.cols[5]), alpha = 0.5))), order.by = "freq", text.scale = 1.7, keep.order = TRUE)
dev.off()
}
if (write.ids == TRUE) {
idx <- which(names(list.of.sets) %in% my.intersection)
write_out(Reduce(intersect, list.of.sets[idx]), my.name)
}
return(full.set)
}
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Plot Network
# Takes as arguments;
# Anetwork = A network from the network function
# my.layout = layout, ex: circular, hierarchical etc.
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
plot_Anetwork <- function(Anetwork, my.layout) {
my_net <- data.frame(Anetwork$node1, Anetwork$node2)
colnames(my_net) <- c("source", "target")
my_net <- network(my_net, directed = FALSE, matrix.type="edgelist")
group <- ifelse(grepl("miR|let", network.vertex.names(my_net)), "#3B5249", "#A1E8AF")
weights <- log2(1/(ifelse(Anetwork$fdr == 0, max(Anetwork$fdr), Anetwork$fdr)))/100
dir <- ifelse(Anetwork$cor_dir == "+", "#E1AA7D", as.character(Anetwork$cor_dir))
dir <- ifelse(dir == "-", "#877F75", as.character(dir))
dir <- ifelse(dir == "0", "#A1E8AF", as.character(dir))
ggnet2(my_net, node.color = group, edge.color = dir, edge.size = weights, mode=my.layout, size = 0, label=TRUE, label.size = 2, label.color = group) +
geom_point(aes(color = color), size = 2, color = "white") +
geom_point(aes(color = color), size = 2, alpha = 0.5) + geom_point(aes(color = color), size = 1)
}
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Ranking of Enrichment Results
# Takes as arguments;
# A list containing 5 datasets to be compared with enrichment results from the mirnaPwEnrich() funtion.
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
RankSumScore <- function(list.of.df) {
D1 <- list.of.df[[1]]
D1 <- D1[D1$Pval <= 0.05,]
D1 <- data.frame(gsub(" - Homo sapiens [(]human[)]", "", as.character(rownames(D1))), as.numeric(rank((1/D1$Pval)))/nrow(D1), 1/D1$FDR)
colnames(D1) <- c("PW", "miRNAs", "FDR1")
D2 <- list.of.df[[2]]
D2 <- D2[D2$Pval <= 0.05,]
D2 <- data.frame(gsub(" - Homo sapiens [(]human[)]", "", as.character(rownames(D2))), as.numeric(rank((1/D2$Pval)))/nrow(D2), 1/D2$FDR)
colnames(D2) <- c("PW", "Genes.BG.DE", "FDR2")
D3 <- list.of.df[[3]]
D3 <- D3[D3$Pval <= 0.05,]
D3 <- data.frame(gsub(" - Homo sapiens [(]human[)]", "", as.character(rownames(D3))), as.numeric(rank((1/D3$Pval)))/nrow(D3), 1/D3$FDR)
colnames(D3) <- c("PW", "Genes.BG.ALL", "FDR3")
D4 <- list.of.df[[4]]
D4 <- D4[D4$Pval <= 0.05,]
D4 <- data.frame(gsub(" - Homo sapiens [(]human[)]", "", as.character(rownames(D4))), as.numeric(rank((1/D4$Pval)))/nrow(D4), 1/D4$FDR)
colnames(D4) <- c("PW", "miRNAs.Genes.BG.DE", "FDR4")
D5 <- list.of.df[[5]]
D5 <- D5[D5$Pval <= 0.05,]
D5 <- data.frame(gsub(" - Homo sapiens [(]human[)]", "", as.character(rownames(D5))), as.numeric(rank((1/D5$Pval)))/nrow(D5), 1/D5$FDR)
colnames(D5) <- c("PW", "miRNAs.Genes.BG.ALL", "FDR5")
D <- merge(D1, D2, by ="PW", all.x=TRUE, all.y=TRUE)
D <- merge(D, D3, by ="PW", all.x=TRUE, all.y=TRUE)
D <- merge(D, D4, by ="PW", all.x=TRUE, all.y=TRUE)
D <- merge(D, D5, by ="PW", all.x=TRUE, all.y=TRUE)
rownames(D) <- D$PW
D$PW <- NULL
DRM <- D[, c(1,3,5,7,9)]
DRM <- DRM[rowSums(is.na(DRM)) < 3, ]
DFDR <- D[, c(2,4,6,8,10)]
DFDR <- DFDR[rowSums(is.na(DFDR)) < 3, ]
DRM$RankMean <- rowMeans(DRM, na.rm = TRUE)
DRM <- DRM[order(DRM$RankMean, decreasing = TRUE),]
DFDR$FDRMean <- rowMeans(DFDR, na.rm = TRUE)
DFDR <- DFDR[match(rownames(DRM), rownames(DFDR)),]
D <- cbind(DRM, DFDR)
return(D)
}
library(devtools)
install_github("vqv/ggbiplot")
devtools::install_github("rstudio/shiny")
version()
version
library(devtools)
sessionInfo()
install.packages("devtools")
install.packages("devtools")
library(devtools)
sessionInfo()
install_github("vqv/ggbiplot")
library(devtools)
if (!require("devtools"))
install.packages("devtools")
devtools::install_github("rstudio/shiny")
install.packages("R.utils")
devtools::install_github("rstudio/shiny")
devtools::install_github("rstudio/shiny")
list.of.packages <- c("limma", "sva", "glmnet", "openxlsx", "xlsx", "ggplot2", "heatmap.plus", "plyr", "data.table", "RColorBrewer", "squash", "survcomp", "survminer", "scales", "rms", "stackoverflow")
lapply(list.of.packages, library, character.only=T)
install.packages(XLSX)
install.packages("xlsx")
list.of.packages <- c("limma", "sva", "glmnet", "openxlsx", "xlsx", "ggplot2", "heatmap.plus", "plyr", "data.table", "RColorBrewer", "squash", "survcomp", "survminer", "scales", "rms", "stackoverflow")
lapply(list.of.packages, library, character.only=T)
library(viridis)
viridis(300)
viridis(2)
viridis(2, begin = 0.1)
viridis(2, end = 0.9)
viridis(2, end = 0.8)
viridis(2, begin = 0.1, end = 0.8)
viridis(2, end = 0.8)
viridis(2, end = 0.7)
viridis(2, end = 0.7, option = "plasma")
viridis(2, option = "plasma")
viridis(2, option = "magma")
viridis(2, begin = 0.2, option = "magma")
viridis(2, begin = 0.2, option = "plasma")
viridis(2, begin = 0.5, option = "plasma")
viridis(2, begin = 0.3, option = "plasma")
viridis(2, begin = 0.6, option = "plasma")
viridis(2, begin = 0.6, end = 0.9, option = "plasma")
viridis(2, end = 0.9, option = "plasma")
viridis(2, end = 0.9, option = "magma")
viridis(2, begin = 0.3, option = "magma")
viridis(2, begin = 0.3, end = 0.9 option = "magma")
viridis(2, begin = 0.3, end = 0.9, option = "magma")
viridis(2, begin = 0.5, end = 0.9, option = "magma")
viridis(2, begin = 0.2, end = 0.9, option = "magma")
viridis(2, begin = 0.2, end = 0.8, option = "magma")
viridis(2, begin = 0.4, end = 0.8, option = "magma")
viridis(2, begin = 0.1, end = 0.8, option = "magma")
rep(3, "grey")
rep("grey", 3)
library(randomForest)
A <- c(12,3,45,5)
B <- c(4,5,6,7,8)
list(A, B)
list(c(A, B))
list(A, B)
ny <- list(A, B)
ny
ny[[1]]
ny[[1]][1]
class(ny[[1]])
B <- c("AB", "ER", "hER")
A <- c("AB", "ER", "hER")
ny <- list(A, B)
ny
ny[[1]]
grep("AB", ny[[1]])
citation(glmnet)
citation("glmnet")
install.packages("biocstyle")
BiocManager::install("biocstyle")
BiocManager::install("BiocStyle")
rnorm(n = 10, mean = 0, sd = 1)
sample(1:1000, 10)
sample(1:100, 10)
sample(1:1000, 10)
test <- list(X = c("A", "B", "C"), Y = c("A", "C"), Z = c("A", "C", "D"))
test
Reduce(intersect, test)
test <- list(X = list(c("A", "B", "C"), c(1,2,3)), Y = list(c("A", "C"), c(1,5)), Z = list(c("A", "C", "D"), c(2,3,5)))
test
test <- list(list(c("A", "B", "C"), c(1,2,3)), list(c("A", "C"), c(1,5)), list(c("A", "C", "D"), c(2,3,5)))
test
test[1,]
test[[1,]]
test[[1]]
test[,][[1]]
test[[,]][[1]]
test[[1]][1]
test[[1]][[1]]
test[[1]][[,]]
unlist(test)
do.call(rbind, test)
do.call(rbind, unlist(test))
as.data.frame(as.matrix(test))
as.data.frame.list(test)
lapply(test, '[[', 1)
Reduce(intersect, lapply(test, '[[', 1))
Reduce(intersect, lapply(test, '[[', 2))
lapply(test, '[[', 2)
test <- list(list(c("A", "B", "C"), c(3)), list(c("A", "C"), c(1)), list(c("A", "C", "D"), c(2)))
test
Reduce(intersect, lapply(test, '[[', 1))
Reduce(mean, lapply(test, '[[', 2))
lapply(test, '[[', 2)
unlist(lapply(test, '[[', 2))
mean(unlist(lapply(test, '[[', 2)))
library(pcaMethods)
setwd("~/Desktop/Thilde/MS_MS_TIF_analysis_2014_2015/Pipeline/DataExamples/txtfiles_and_other_tests")
library(openxlsx)
test <- openxlsx::read.xlsx("glycandataNAs.xlsx")
rownames(test) <- test$X1
test$X1 <- NULL
test <- as.matrix(as.data.frame(lapply(test, as.numeric)))
head(test)
class(test)
test[,30]
llsRes <- nni(test, k=10, method="llsImpute", allGenes=TRUE)
llsRes
llsRes
nObs(llsRes)
result <- llsImpute(test, k = 6, correlation="pearson", allVariables=TRUE)
result <- llsImpute(test, k = 6, correlation="pearson", allVariables=TRUE)
cObs <- completeObs(result)
cObs
cObs[,30]
test[,30]
data("metaboliteData")
head(metaboliteData)
dim(metaboliteData)
result <- completeObs(llsImpute(test, k = 6, correlation="pearson", allVariables=TRUE))
result
result[,30]
test[,30]
result
dim(result)
class(result)
class(test)
dim(test)
dim(test)
is.numeric(test)
classData(test)
ClassData(test)
ny <- c()
llsImpute(ny, k = 6, correlation="pearson", allVariables=TRUE)
ny <- matrix(c(1,2,3,4), c("A", 1,2,3))
ny <- data.frame(c(1,2,3,4), c("A", 1,2,3))
ny
llsImpute(ny, k = 6, correlation="pearson", allVariables=TRUE)
checkData(test)
checkData(test)[1]
checkData(test)[1] = TRUE
checkData(test)[1] == TRUE
arg.data <- openxlsx::read.xlsx("glycandataNAs.xlsx", colNames = TRUE, rowNames = TRUE)
arg.data
class(arg.data)
checkData(arg.data)
class(arg.data)
checkData(as.matrix(arg.data))
checkData(as.matrix(arg.data)) == FALSE
if (checkData(as.matrix(my.data))[1] == FALSE) {
my.data <- as.data.frame(lapply(my.data, as.numeric))
}
if (checkData(as.matrix(arg.data))[1] == FALSE) {
arg.data <- as.data.frame(lapply(arg.data, as.numeric))
}
arg.data
checkData(arg.data)
checkData(as.matrix(arg.data))
my.data <- data.frame(completeObs(llsImpute(as.matrix(my.data), k = 10, correlation="pearson", allVariables=TRUE)))
arg.data <- data.frame(completeObs(llsImpute(as.matrix(arg.data), k = 10, correlation="pearson", allVariables=TRUE)))
arg.data
class(arg.data)
my.data <- openxlsx::read.xlsx("glycandataNAs.xlsx", colNames = TRUE, rowNames = TRUE)
class(my.data)
my.data
checkData(as.matrix(my.data))[1] == FALSE
if (checkData(as.matrix(my.data))[1] == FALSE) {
my.data <- as.data.frame(lapply(my.data, as.numeric))
}
my.data <- data.frame(completeObs(llsImpute(as.matrix(my.data), k = 10, correlation="pearson", allVariables=TRUE)))
my.data
class(my.data)
my.data <- openxlsx::read.xlsx("glycandataNAs.xlsx", colNames = TRUE, rowNames = TRUE)
if (checkData(as.matrix(my.data))[1] == FALSE) {
my.data <- as.data.frame(lapply(my.data, as.numeric))
}
my.data <- completeObs(llsImpute(as.matrix(my.data), k = 10, correlation="pearson", allVariables=TRUE))
my.data
class(my.data)
my.data
my.data < 0
ny <- lapply(my.data, 1, function(x), x < 0)
ny <- apply(my.data, 1, function(x), x < 0)
ny <- apply(my.data, 1, function(x) x < 0)
ny
which(y == FALSE)
which(ny == FALSE)
which(ny == TRUE)
my.data[2788,]
my.data[2788]
ny2 <- as.vector(my.data)
length(ny2)
ny[2788]
head(my.data)
ny2[2788]
my.data[rowSums(my.data < 0) == 0,]
has.neg <- apply(my.data, 1, function(row) any(row < 0))
which(has.neg)
my.data[23,]
my.data[23,] < 0
unique(my.data[23,] < 0)
which(my.data[23,] < 0)
my.data[23,16]
