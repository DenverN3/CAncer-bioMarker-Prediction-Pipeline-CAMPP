GO <- TOPGO("BP", my.univers, p, GO.background, nterms)
if (my.barp == TRUE) {
png(filename = paste0(filename, "_barplot.png"), height = 600, width = 1000)
barplot_func(GO)
dev.off()
}
if (my.corrp == TRUE) {
png(filename = paste0(filename, "_corrplot.png"), height = 800, width = 1200)
corrplot_func(GO)
dev.off()
}
return(GO)
}
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
GO_map_to <- function(humanGO, my.GOs, my.proteins.vector, my.gene.vector) {
mappedunip <- lapply(my.GOs$GO.ID, function(x) intersect(sort(as.character(my.proteins.vector)), sort(as.character(humanGO[humanGO$V5 %in% x,]$V2))))
mappedunip <- do.call(rbind,lapply(mappedunip, function(x) paste(x, collapse = ",")))
my.GOs$uniprot <- as.character(mappedunip[,1])
mappedgene <- lapply(my.GOs$GO.ID, function(x) intersect(sort(as.character(my.gene.vector)), sort(as.character(humanGO[humanGO$V5 %in% x,]$V3))))
mappedgene <- do.call(rbind,lapply(mappedgene, function(x) paste(x, collapse = ",")))
my.GOs$symbol <- as.character(mappedgene[,1])
return(my.GOs)
}
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# PRINCIPAL COMPONENT ANALYSIS:
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Function that creates a rotation object
rotation_func <- function(my.data) {
pca <- prcomp(t(my.data), center = TRUE, scale=TRUE)
rotation <- data.frame(pca$rotation)
return(rotation)
}
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# BOXPLOT VISUALIZATION:
# takes as arguments:
# my.data = abundance/expresssion data
# my.group = vector of groups/lables and
# my.colors = vector of desired colors (must be the same length as levels of my.group)
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
boxplots <- function(my.data, my.group, my.colors) {
pca <- prcomp(t(my.data), center = TRUE, scale=TRUE)
pc <- data.frame(predict(pca, newdata = t(my.data)))
data <- melt(pc[1:ncol(pc),], var='PC')
group_reps <- data.frame(c(replicate(ncol(pc), my.group)))
bp_data<- data.frame(group_reps, data)
colnames(bp_data) <- c("group", "PC", "values")
ggplot(data=bp_data, aes(x=PC, y=values, fill=group)) +  theme_bw() + geom_boxplot(stat="boxplot", position="dodge") + scale_fill_manual(values = my.colors) + theme(legend.text = element_text(size = 16, face="bold"), axis.title=element_text(size=16,face="bold")) + guides(colour = guide_legend(override.aes = list(size=6))) + theme(legend.position = "top") + theme(axis.text=element_text(size=10, face="bold")) + theme(axis.text = element_text(colour = "black"))
}
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# PATHWAY ENRICHMENT ANALYSIS:
# takes as arguments:
# background = protein background for enrichment
# my.u2e.map = a map of uniprot IDs to entrez IDs
# my.proteins = list of uniprot IDs of interest
# my.name =  name of pdf file
# if my.plot = TRUE pdf will be generated
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
enrich_pathway <- function(background, my.u2e.map, my.proteins, my.name, my.plot) {
entrez.data <- my.u2e.map[my.u2e.map$uniprot %in% my.proteins, ]
my.pathway <- enrichPathway(as.character(entrez.data$entrez), organism = "human", pvalueCutoff = 0.05, pAdjustMethod = "fdr", qvalueCutoff = 0.05, as.character(background$entrez), minGSSize = 3, readable = T)
if (my.plot == TRUE) {
pdf(filename = paste0(my.name,".pdf"), height = 800, width = 1200)
cnetplot(my.pathway, categorySize="pvalue")
dev.off()
}
return(my.pathway)
}
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# FUNCTION FOR RANDOM FOREST
# Takes as arguments:
# my.seed = A random seed
# my.data = matrix of countes/expression/abundance
# my.groups = vector of group IDs, must be as.factor()
# my.nhits = Number of hits to return from RF ranking.
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
my_forest_conver <- function(my.seed, my.data, my.groups) {
set.seed(my.seed)
rf <- randomForest(x=my.data, y=my.groups, ntree=3000)
plot(rf)
return(rf)
}
my_forest <- function(my.seed, my.data, my.groups) {
set.seed(my.seed)
rfsel <- varSelRF(my.data, my.groups, ntree=3000, ntreeIterat=1500, vars.drop.frac=0.2)
res <- rfsel$selected.vars
return(res)
}
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# FUNCTION FOR LASSO REGRESSION
# Takes as arguments:
# my.seed = A random seed
# my.data = matrix of countes/expression/abundance
# my.groups = vector of group IDs, must be as.integer()
# If my.multinorm=TRUE the my.groups vector has > 2 groups, else my.multinorm=FALSE which will result in binomial regression.
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
LASSO_protein <- function(my.seed, my.data, my.group, my.multinorm=TRUE) {
# orginal seed was 1011
if(my.multinorm == TRUE) {
set.seed(my.seed)
my.fit <- cv.glmnet(x = t(my.data), y = my.group, family="multinomial", type.multinomial = "grouped", nfolds = 10)
my.coef <- coef(my.fit, s=my.fit$lambda.min)
my.ma <- as(my.coef$`1`, "matrix")
rm(my.fit)
rm(my.coef)
}
else {
set.seed(my.seed)
my.fit <- cv.glmnet(x = t(my.data), y = my.group, family = "binomial", type.measure = "class", nfolds = 10)
my.coef <- coef(my.fit, s=my.fit$lambda.min)
my.ma <- as(my.coef, "matrix")
rm(my.fit)
rm(my.coef)
}
my.ma <- names(my.ma[my.ma[,1] != 0, ])
#my.ma <- my.data[rownames(my.data) %in% my.ma, ]
return(my.ma[-1])
}
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Plot UpSetR
# Takes as arguments;
# list.of.sets = list with sets to plot
# my.intersection = the names of the sets to intersect
# my.name = name of output plot
# my.cols = colors vector with as, one color per set
# if my.plot= TRUE a pdf is writen out, og write.ids = TRUE, write out intersection of all sets
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
plot_upsetR <- function(list.of.sets, my.intersection, my.name, my.cols, my.plot, write.ids) {
full.set <- data.frame(unique(sort(c(unlist(list.of.sets)))))
colnames(full.set) <- "Accession"
for (name in  names(list.of.sets)) {
full.set <- data.frame(full.set, ifelse(full.set$Accession %in% as.character(list.of.sets[[name]]), 1, 0))
}
colnames(full.set) <- c("Accession", names(list.of.sets))
metadata <- data.frame("sets" = colnames(full.set)[-1], "sets2" = colnames(full.set)[-1])
if (my.plot==TRUE) {
pdf(paste0(my.name, ".pdf"), height = 6, width = 10)
upset(full.set, sets=colnames(full.set)[2:ncol(full.set)], sets.bar.color = my.cols, set.metadata = list(data = metadata, plots = list(list(type="matrix_rows", column = "sets", colors = c("TIF" = my.cols[1], "Nglyco" = my.cols[2], "Plasma" = my.cols[3], "Secreted"=my.cols[4], "Exosomes"=my.cols[5]), alpha = 0.5))), order.by = "freq", text.scale = 1.7, keep.order = TRUE)
dev.off()
}
if (write.ids == TRUE) {
idx <- which(names(list.of.sets) %in% my.intersection)
write_out(Reduce(intersect, list.of.sets[idx]), my.name)
}
return(full.set)
}
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# UNIPROT ACCESSION TO GENE NAME
# Takes as arguments;
# my.vector = vector uniprot IDs
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
uniprot_to_name <- function(my.vector) {
ensembl <- useMart('ensembl', dataset = "hsapiens_gene_ensembl")
annot1 <- getBM(attributes=c("uniprotswissprot", "hgnc_symbol", "uniprot_gn"), filters="uniprotswissprot", values=my.vector, mart=ensembl)
annot1$uniprot_gn <- NULL
colnames(annot1) <- c("Accession", "name")
annot2 <- hugo[hugo$Accession %in% my.vector, ]
annot2[3] <- NULL
annot <- rbind(annot1, annot2)
annot <- unique(annot[order(annot$Accession),])
return(annot)
}
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# WRITE OUT
# Takes as arguments;
# my.proteins = vector of uniprot IDs OR dataframe of expression/abundance values with IDs as rownames
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
write_out <- function(my.proteins, my.name) {
if (class(my.proteins) == "data.frame") {
my.proteins$Accession <- rownames(my.proteins)
my.proteins$my.order <- 1:nrow(my.proteins)
} else {
my.proteins <- data.frame(my.proteins)
colnames(my.proteins) <- "Accession"
my.proteins$my.order <- 1:nrow(my.proteins)
}
my.genes <- uniprot_to_name(my.proteins$Accession)
my.merged <- merge(my.proteins, my.genes, by ="Accession", all.x=TRUE)
my.merged <- my.merged[order(my.merged$my.order),]
my.merged$my.order <- NULL
write.table(my.merged, paste0(my.name,".txt"), quote = FALSE, row.names = FALSE, sep = "\t")
#return(my.merged)
}
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# miRNA-miRNA co-expression network with spearman analysis.
# Takes as arguments:
# data = a dataframe with expression/abundance counts
# direction = vector specifying if the given miRNA is up -or down regulated in the given comparison ("up" or "down")
# coCorr, coFDR = cut-off for significant fdr and correlation
# name = name of output file (as string)
# IF genes=NULL then only miRNAs will be used, or the user may provide a list of miRNA-gene targets.
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
my_networks <- function(data, direction, cuofcorr, cuoffdr) {
combinations <- combs(as.character(rownames(data)), 2)
df1_names <- data.frame(combinations[,1])
colnames(df1_names) <- "first"
df2_names <- data.frame(combinations[,2])
colnames(df2_names) <- "second"
temp_data <- data
names <- rownames(temp_data)
first <- rownames(temp_data)
rownames(temp_data) <- NULL
temp_data <- cbind(temp_data, names, first)
df1 <- merge(df1_names, temp_data, by="first", sort = FALSE)
df1 <- cbind(df2_names, df1)
df1 <- with(df1, df1[order(second) , ])
df2_names <- data.frame(df1$second)
colnames(df2_names) <- "names"
df1_names <- data.frame(df1$first)
colnames(df1_names) <- "first"
df1$first <- NULL
df1$second <- NULL
df1$names <- NULL
df2 <- merge(df2_names, temp_data, by="names", sort = FALSE)
df2$first <- NULL
df2$names <- NULL
df1 <- as.matrix(df1)
df2 <- as.matrix(df2)
spear_corr <- sapply(1:nrow(df1), function(i) cor(df1[i,], df2[i,], method = "spearman"))
spear_corr <- data.frame(spear_corr)
colnames(spear_corr) <- "cor_coef"
# spearson correlation p-values
spear_p_val <- sapply(1:nrow(df1), function(i) cor.test(df1[i,], df2[i,], method = "spearman")$p.value)
spear_p_val <- data.frame(spear_p_val)
colnames(spear_p_val) <- "pval"
# correction for multiple testing with fdr
fdr <- data.frame(p.adjust(spear_p_val$pval, method = "fdr"))
colnames(fdr) <- "fdr"
spear_corr_full <- cbind(df1_names, df2_names, spear_corr, fdr)
spear_corr_full$cor_dir <- ifelse(spear_corr_full$cor_coef >= 0, "+", "-")
spear_corr_full$cor_coef <- abs(spear_corr_full$cor_coef)
spear_sig <- spear_corr_full[spear_corr_full$cor_coef >= cuofcorr & spear_corr_full$fdr < cuoffdr, ]
max_min <- range(spear_sig$fdr[spear_sig$fdr != 0])
spear_sig$fdr <- ifelse(spear_sig$fdr == 0, max_min[1], spear_sig$fdr)
spear_sig$inverse_fdr <- -1*log(spear_sig$fdr)
spear_sig <- merge(spear_sig, direction, by ="first")
spear_sig$dir <- ifelse(spear_sig$cor_dir == '+' & spear_sig$direction == "up", "u", "o")
spear_sig$dir <- ifelse(spear_sig$cor_dir == '+' & spear_sig$direction == "down", "d", spear_sig$dir)
return(spear_sig)
}
get_nodes <- function(my.map, my.network, name) {
nwk <- merge(my.network, my.map, by.x="first", by.y="Accession", all.x=TRUE)
nwk <- merge(nwk, my.map, by.x="names", by.y="Accession", all.x=TRUE)
nwk$node1 <- ifelse(is.na(nwk$name.x), as.character(nwk$first),  nwk$name.x)
nwk$node2 <- ifelse(is.na(nwk$name.y), as.character(nwk$names),  nwk$name.y)
nwk$name.x <- NULL
nwk$name.y <- NULL
write.table(nwk, paste0(name,"network.txt"), sep="\t", quote = FALSE, row.names = FALSE)
return(nwk)
}
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# CHI-SQUARED TEST AND ODDS RATIO
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
get_stats <- function(l1, l2, l3) {
mytab <- data.frame(c(length(intersect(l1, l2)), length(l2)-length(intersect(l1, l2))), c(length(intersect(l1, l3)), length(l3)-length(intersect(l1, l3))))
#chi <- chisq.test(mytab)$p.val
#OR <- (mytab[1,1]*mytab[2,2])/(mytab[1,2]*mytab[2,1])
#return(c(chi, OR))
fisher <- fisher.test(mytab)
return(fisher)
}
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# 3D PLOT
# Takes as arguments;
# my.data = a  N x 3 dataframe of expression/abundance data with IDs as rownames OR a pca object with 3 PCs
# my.colors = a vector of colors, same length as number of samples
# my.r =  size of spheres
# my.names = vector with names to put on the axis.
# if is.PCAobejct = TRUE, data will be treated as a pca object.
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
my_3Dplot <- function(my.data, my.colors, my.r, my.names, is.PCAobejct) {
if(is.PCAobejct == TRUE) {
pca <- prcomp(t(my.data), center = TRUE, scale=TRUE)
pc <- data.frame(predict(pca, newdata = t(my.data)))
}
else {
pc <- data.frame(t(my.data))
colnames(pc) <- c("PC1", "PC2", "PC3")
}
rgl.bg(color = "antiquewhite")
rgl.spheres(pc$PC1, pc$PC2, pc$PC3, r=my.r, col= my.colors)
lim <- function(x){c(-max(abs(x)), max(abs(x)))}
rgl.lines(lim(pc$PC1), c(0,0), c(0,0), color= "grey50")
rgl.lines(c(0,0), lim(pc$PC2),  c(0,0), color= "grey50")
rgl.lines(c(0,0), c(0,0),  lim(pc$PC3),  color= "grey50")
ellips <- ellipse3d(cov(cbind(pc$PC1, pc$PC2, pc$PC3)), centre = c(mean(pc$PC1), mean(pc$PC2), mean(pc$PC3)), level = 0.95)
wire3d(ellips, col="grey50", lit=FALSE)
aspect3d(1,1,1)
axes <- rbind(c(lim(pc$PC1)[2], 0, 0), c(0, lim(pc$PC2)[2], 0), c(0, 0, lim(pc$PC3)[2]))
rgl.texts(axes, text = c(my.names[1], my.names[2], my.names[3]), color = "grey50", adj = c(0.5, -0.8), size = 2)
}
# coo <- 1:720
# for(i in 1:length(coo)){
#   rgl.viewpoint(coo[i])
# }
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# 3D SCATTERPLOT
# Takes as arguments;
# my.data = a  N x 3 dataframe of expression/abundance data with IDs as rownames OR a pca object with 3 PCs
# my.colors = a vector of colors, same length as number of samples
# my.group = vector of group labels, same length as number of samples
# my.names = vector with names to put on the axis.
# if is.PCAobejct = TRUE, data will be treated as a pca object.
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
my_3Dscatter <- function(my.data, my.colors, my.group, my.names, is.PCAobejct) {
if(is.PCAobejct == TRUE) {
pca <- prcomp(t(my.data), center = TRUE, scale=TRUE)
pc <- data.frame(predict(pca, newdata = t(my.data)))
}
else {
pc <- data.frame(t(my.data))
colnames(pc) <- c("PC1", "PC2", "PC3")
}
greycol <- rep("grey60", nrow(my.data))
with(pc, text3D(PC1, PC2, PC3, col = my.colors, theta = 10, phi=15, labels = my.group, cex = 0.8, bty = "b2", d = 3, clab = c("Urban","Pop"), adj = 0.6, font = 2, xlab=my.names[1], ylab=my.names[2], zlab=my.names[3]))
with(pc, scatter3D(PC1, PC2, PC3, col=greycol, type = "h", add = TRUE))
}
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# ENTREZ GENE IDs AND ASSOCIATED LOGFC FROM A DE-TABLE
# Takes as arguments;
# my.table = DE_table from the DE_limma function
# my.u2e.map = uniprot to entrezID map
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
get_entrez <- function(my.table, my.u2e.map) {
my.table <- data.frame(rownames(my.table), my.table$logFC)
colnames(my.table) <- c("uniprot", "logFC")
final.table <- merge(my.table, my.u2e.map, by = "uniprot")
final.table <- final.table[order(final.table$entrez), ]
logFC <- final.table$logFC
names(logFC) <- final.table$entrez
return(logFC)
}
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# FUNCTION FOR KEGG PATHWAY ENRICHMENT ANALYSIS:
# Takes as arguments;
# my.table = DE_table from the DE_limma function
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
keggs_entrez<- function(my.table) {
ensembl <- useMart('ensembl', dataset="hsapiens_gene_ensembl")
annot <- getBM(attributes=c("uniprot_swissprot", "entrezgene", "uniprot_genename"), filters="uniprot_swissprot", values=rownames(my.table), mart=ensembl)
annot <- annot[match(rownames(my.table), annot$uniprot_swissprot),]
annot <- cbind(my.table, annot)
annot <- annot[order(as.numeric(annot$entrezgene)), ]
logFC <- annot$logFC
names(logFC) <- annot$entrezgene
return(logFC)
}
my.keggs <- function(my.geneset, my.keggset) {
keggres <- gage(my.geneset, gsets=my.keggset, same.dir=FALSE)
keggpathways <- data.frame(id=rownames(keggres$greater), keggres$greater)
keggpathways <- keggpathways[!is.na(keggpathways$p.val),]
keggpathways <- as.character(keggpathways[keggpathways$p.val< 0.05,]$id)
keggids <- substr(keggpathways, start=1, stop=8)
pv.out.list <- sapply(keggids, function(pid) pathview(gene.data=both, pathway.id=pid, species="hsa", gene.idtype="KEGG", both.dirs = TRUE))
return(pv.out.list)
}
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# FUNCTION FOR CLUSTER ANALYSIS
# optimal_nc function takes as arguments:
# a dataframe of expression/abundance values
# plot_clusters function takes as arguments:
# a dataframe of expression/abundance values and number of clusters
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Calculating number of optimal clusters - clustGap
optimal_nc <- function (my.dataframe) {
pam1 <- function(my.dataframe,k) list(cluster = pam(my.dataframe,k, cluster.only=TRUE))
optimal_number <- clusGap(t(my.dataframe), FUN = pam1, K.max = 15, B = 500)
plot(optimal_number)
}
# Plotting clusters with patient IDs
plot_clusters <- function(my.dataframe, my.clusters) {
d <- dist(t(my.dataframe))
clust <- kmeans(d, my.clusters)
library(fpc)
library(cluster)
clusplot(as.matrix(d), clust$cluster, color=TRUE, shade=TRUE, col.txt=col, col.clus = c("dodgerblue3", "magenta","springgreen2"), col.p=col, labels=2, cex=0.6, lines=0, main="CLUSPLOT")
}
Overlap_GOplot <- function(my.set, my.lfc.cols, my.rib.cols) {
genenames <- uniprot_to_name(my.set$Accession)
my.set <- merge(my.set, genenames, by ="Accession", all.x=TRUE, all.y=FALSE)
my.set <- my.set[!is.na(my.set$name),]
rownames(my.set) <- my.set$name
my.set$name <- NULL
my.set$Accession <- NULL
my.set$logFC <- rnorm(nrow(my.set), 0, 2)
GOChord(as.matrix(my.set), lfc.col = my.lfc.cols, ribbon.col = my.rib.cols)
}
setwd("~/Desktop")
mydata <- read.xlsx("mydata.xlsx", sheet = 1)
head(mydata)
setwd("~/Desktop/Thilde/MS_MS_TIF_analysis_2014_2015/TIF_miRNA/Data")
serum <- read.delim("miRNA_serum.txt", header = TRUE)
head(serum)
write.xlsx(serum, "mydata.xlsx")
write.xlsx2(serum, "mydata.xlsx", sheetName = "Sheet1", col.names = TRUE, row.names = TRUE, append = FALSE)
write.xlsx(serum, "mydata.xlsx", sheetName = "Sheet1", col.names = TRUE, row.names = TRUE, append = FALSE)
openxlsx::write.xlsx(serum, file = "mydata.xlsx", colNames = TRUE, borders = "columns")
openxlsx::write.xlsx(serum, file = "mydata.xlsx", colNames = TRUE, borders = "columns")
write.csv(serum, file = "mydata.csv", sep = ";", row.names = TRUE, col.names = TRUE, quote = FALSE)
write.csv(serum, "mydata.csv", quote = FALSE, row.names = TRUE, col.names = TRUE)
write.csv(serum, "mydata.csv", quote = FALSE, row.names = TRUE)
write.csv2(serum, "mydata.csv", quote = FALSE, row.names = TRUE)
setwd("~/Desktop/Thilde/MS_MS_TIF_analysis_2014_2015/Pipeline/DataExamples")
arg.metadata <- openxlsx::read.xlsx("miRNAmetadata.xlsx", colNames = TRUE, rowNames = FALSE)
arg.metadata
arg.group <- as.factor(as.character(arg.metadata$group))
arg.group
DE.res <- openxlsx::read.xlsx("myresults_DE.xlsx", colNames = TRUE, rowNames = FALSE)
DE.res
res.DE.names <- DE$name
DE.res <- openxlsx::read.xlsx("myresults_DE.xlsx", colNames = TRUE, rowNames = FALSE)
res.DE.names <- DE.res$name
res.DE.names
arg.data <- openxlsx::read.xlsx("miRNAData.xlsx", colNames = TRUE, rowNames = TRUE)
data.names <- rownames(arg.data)
arg.data <- as.matrix(as.data.frame(lapply(arg.data, as.numeric)))
rownames(arg.data) <- data.names
head(arg.data)
metadata.surv <- arg.metadata[which(arg.metadata$survival == 1),]
arg.samples <- metadata.surv$ids
arg.samples
head(arg.metadata)
arg.metadata <- openxlsx::read.xlsx("miRNAmetadata.xlsx", colNames = TRUE, rowNames = FALSE)
arg.metadata
res.DE.names
metadata.surv <- arg.metadata[which(arg.metadata$survival == 1),]
arg.samples <- metadata.surv$ids
arg.samples
data.surv <- arg.data[,colnames(arg.data) %in% arg.samples]
metadata.surv
dim(metadata.surv)
dim(data.surv)
colnames(data.surv)
metadata.surv$ids
arg.samples
data.surv <- data.surv[rownames(data.surv) %in% res.DE.names,]
dim(data.surv)
surv_object <- data.frame(t(data.surv), as.numeric(metadata.surv$outcome.time), metadata.surv$age, metadata.surv$outcome)
dim(surv_object)
head(surv_object)
colnames(surv_object) <- c(rownames(data.surv), "outcome.time", "age", "outcome")
head(surv_object)
features <- rownames(data.surv)
dd <- datadist(surv_object); options(datadist='dd')
library(rms)
features <- rownames(data.surv)
dd <- datadist(surv_object); options(datadist='dd')
features
for (f in features) {
acall <- parse(text = paste0("result <- cph(Surv(outcome.time, outcome) ~ rcs(age) + rcs(", as.character(f),"), data = surv_object, x=TRUE,y=TRUE)"))
eval(acall)
covariate_linearity[[as.character(f)]] <- result
}
covariate_linearity <- list()
for (f in features) {
acall <- parse(text = paste0("result <- cph(Surv(outcome.time, outcome) ~ rcs(age) + rcs(", as.character(f),"), data = surv_object, x=TRUE,y=TRUE)"))
eval(acall)
covariate_linearity[[as.character(f)]] <- result
}
covariate_linearity
covariate_linearity$hsalet7a000377
covariate_linearity  <- lapply(covariate_linearity, function(x) anova(x))
covariate_linearity$hsalet7a000377
anova(covariate_linearity$hsalet7a000377)
covariate_linearity <- list()
for (f in features) {
acall <- parse(text = paste0("result <- cph(Surv(outcome.time, outcome) ~ rcs(age) + rcs(", as.character(f),"), data = surv_object, x=TRUE,y=TRUE)"))
eval(acall)
covariate_linearity[[as.character(f)]] <- result
}
covariate_linearity$hsamiR1423p000464
covariate_linearity$hsamiR1423p000464
is.null(covariate_linearity$hsamiR1423p000464)
class(covariate_linearity$hsamiR1423p000464)
length(covariate_linearity$hsamiR1423p000464)
length(covariate_linearity$hsalet7a000377)
length(covariate_linearity$hsalet7d002283)
lapply(covariate_linearity, function(x) length(x))
unlist(lapply(covariate_linearity, function(x) length(x)))
as.numeric(unlist(lapply(covariate_linearity, function(x) length(x))))
which(as.numeric(unlist(lapply(covariate_linearity, function(x) length(x)))) == 1)
head(surv_object)
length(violation)
which(as.numeric(unlist(lapply(covariate_linearity, function(x) length(x)))) == 1)
length(which(as.numeric(unlist(lapply(covariate_linearity, function(x) length(x)))) == 1))
length(which(as.numeric(unlist(lapply(covariate_linearity, function(x) length(x)))) == 10))
length(which(as.numeric(unlist(lapply(covariate_linearity, function(x) length(x)))) == 10)) > 0
length(which(as.numeric(unlist(lapply(covariate_linearity, function(x) length(x)))) == 1)) > 0
which(as.numeric(unlist(lapply(covariate_linearity, function(x) length(x)))) == 1)
remove <- which(as.numeric(unlist(lapply(covariate_linearity, function(x) length(x)))) == 1)
remove
covariate_linearity2 <- covariate_linearity
covariate_linearity2 <- covariate_linearity[-remove]
length(covariate_linearity)
length(covariate_linearity2)
covariate_linearity2  <- lapply(covariate_linearity2, function(x) anova(x))
dim(covariate_linearity2)
dim(covariate_linearity1)
covariate_linearity <- list()
for (f in features) {
acall <- parse(text = paste0("result <- cph(Surv(outcome.time, outcome) ~ rcs(age) + rcs(", as.character(f),"), data = surv_object, x=TRUE,y=TRUE)"))
eval(acall)
covariate_linearity[[as.character(f)]] <- result
}
remove
covariate_linearity[33]
covariate_linearity[34]
covariate_linearity2 <- covariate_linearity[-remove]
covariate_linearity2[34]
covariate_linearity2[33]
covariate_linearity  <- lapply(covariate_linearity, function(x) anova(x))
covariate_linearity  <- lapply(covariate_linearity2, function(x) anova(x))
